# Generated from rules.g4 by ANTLR 4.8
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\36")
        buf.write("\u0084\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\3\2\3\2\3\2\6\2\60\n\2")
        buf.write("\r\2\16\2\61\3\3\3\3\3\3\3\3\3\3\5\39\n\3\3\4\3\4\3\4")
        buf.write("\5\4>\n\4\3\5\3\5\3\5\3\6\3\6\3\6\3\6\3\7\3\7\3\7\3\7")
        buf.write("\3\7\3\b\3\b\3\t\3\t\3\t\5\tQ\n\t\3\n\3\n\3\n\3\n\3\n")
        buf.write("\3\13\3\13\3\13\3\13\3\13\3\f\3\f\3\r\3\r\6\ra\n\r\r\r")
        buf.write("\16\rb\3\16\3\16\3\16\3\16\3\16\5\16j\n\16\3\17\3\17\3")
        buf.write("\17\3\20\3\20\3\20\3\21\3\21\3\22\3\22\3\22\3\23\3\23")
        buf.write("\3\23\3\23\3\23\3\24\3\24\3\24\3\24\3\25\3\25\3\26\3\26")
        buf.write("\3\26\2\2\27\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"")
        buf.write("$&(*\2\b\3\3\3\3\3\2\21\22\3\2\7\b\4\2\21\22\33\33\3\2")
        buf.write("\16\20\3\2\30\32\2|\2/\3\2\2\2\48\3\2\2\2\6=\3\2\2\2\b")
        buf.write("?\3\2\2\2\nB\3\2\2\2\fF\3\2\2\2\16K\3\2\2\2\20P\3\2\2")
        buf.write("\2\22R\3\2\2\2\24W\3\2\2\2\26\\\3\2\2\2\30^\3\2\2\2\32")
        buf.write("i\3\2\2\2\34k\3\2\2\2\36n\3\2\2\2 q\3\2\2\2\"s\3\2\2\2")
        buf.write("$v\3\2\2\2&{\3\2\2\2(\177\3\2\2\2*\u0081\3\2\2\2,-\5\4")
        buf.write("\3\2-.\t\2\2\2.\60\3\2\2\2/,\3\2\2\2\60\61\3\2\2\2\61")
        buf.write("/\3\2\2\2\61\62\3\2\2\2\62\3\3\2\2\2\639\5\6\4\2\649\5")
        buf.write("\20\t\2\659\5\30\r\2\669\5\32\16\2\679\7\r\2\28\63\3\2")
        buf.write("\2\28\64\3\2\2\28\65\3\2\2\28\66\3\2\2\28\67\3\2\2\29")
        buf.write("\5\3\2\2\2:>\5\b\5\2;>\5\n\6\2<>\5\f\7\2=:\3\2\2\2=;\3")
        buf.write("\2\2\2=<\3\2\2\2>\7\3\2\2\2?@\5\16\b\2@A\7\33\2\2A\t\3")
        buf.write("\2\2\2BC\7\33\2\2CD\7\16\2\2DE\t\3\2\2E\13\3\2\2\2FG\5")
        buf.write("\16\b\2GH\7\33\2\2HI\7\16\2\2IJ\t\3\2\2J\r\3\2\2\2KL\t")
        buf.write("\4\2\2L\17\3\2\2\2MQ\5\22\n\2NQ\5\24\13\2OQ\7\13\2\2P")
        buf.write("M\3\2\2\2PN\3\2\2\2PO\3\2\2\2Q\21\3\2\2\2RS\7\n\2\2ST")
        buf.write("\t\5\2\2TU\5\26\f\2UV\t\5\2\2V\23\3\2\2\2WX\7\f\2\2XY")
        buf.write("\t\5\2\2YZ\5\26\f\2Z[\t\5\2\2[\25\3\2\2\2\\]\t\6\2\2]")
        buf.write("\27\3\2\2\2^`\7\t\2\2_a\7\33\2\2`_\3\2\2\2ab\3\2\2\2b")
        buf.write("`\3\2\2\2bc\3\2\2\2c\31\3\2\2\2dj\5\34\17\2ej\5\"\22\2")
        buf.write("fj\5$\23\2gj\5\36\20\2hj\5&\24\2id\3\2\2\2ie\3\2\2\2i")
        buf.write("f\3\2\2\2ig\3\2\2\2ih\3\2\2\2j\33\3\2\2\2kl\7\23\2\2l")
        buf.write("m\5 \21\2m\35\3\2\2\2no\5 \21\2op\7\33\2\2p\37\3\2\2\2")
        buf.write("qr\7\27\2\2r!\3\2\2\2st\7\25\2\2tu\7\33\2\2u#\3\2\2\2")
        buf.write("vw\7\24\2\2wx\7\26\2\2xy\7\4\2\2yz\7\5\2\2z%\3\2\2\2{")
        buf.write("|\7\33\2\2|}\7\6\2\2}~\5(\25\2~\'\3\2\2\2\177\u0080\5")
        buf.write("*\26\2\u0080)\3\2\2\2\u0081\u0082\t\7\2\2\u0082+\3\2\2")
        buf.write("\2\b\618=Pbi")
        return buf.getvalue()


class rulesParser ( Parser ):

    grammarFileName = "rules.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'\n'", "'('", "')'", "':'", "<INVALID>",
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                     "<INVALID>", "<INVALID>", "'='", "'>'", "'<'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "INTEGER", "NUMBER", "OUTPUT", "IF",
                      "ELSE", "ELSEIF", "END", "EQUAL", "GREATER", "LESS",
                      "NUMB", "FLOAT", "USE", "ACTION", "CLASS_KEY", "ACTION_MAIN",
                      "LED", "LED_ON", "LED_OFF", "LED_PIN", "VARIABLE",
                      "TEXT", "WHITESPACE", "NEWLINE" ]

    RULE_stmt = 0
    RULE_line = 1
    RULE_v_init = 2
    RULE_decl = 3
    RULE_assign = 4
    RULE_both = 5
    RULE_d_type = 6
    RULE_conditional = 7
    RULE_r_if = 8
    RULE_r_elif = 9
    RULE_relation = 10
    RULE_output = 11
    RULE_other = 12
    RULE_use = 13
    RULE_inst = 14
    RULE_lib = 15
    RULE_class_ = 16
    RULE_action = 17
    RULE_funcall = 18
    RULE_funs = 19
    RULE_led_related = 20

    ruleNames =  [ "stmt", "line", "v_init", "decl", "assign", "both", "d_type",
                   "conditional", "r_if", "r_elif", "relation", "output",
                   "other", "use", "inst", "lib", "class_", "action", "funcall",
                   "funs", "led_related" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    INTEGER=5
    NUMBER=6
    OUTPUT=7
    IF=8
    ELSE=9
    ELSEIF=10
    END=11
    EQUAL=12
    GREATER=13
    LESS=14
    NUMB=15
    FLOAT=16
    USE=17
    ACTION=18
    CLASS_KEY=19
    ACTION_MAIN=20
    LED=21
    LED_ON=22
    LED_OFF=23
    LED_PIN=24
    VARIABLE=25
    TEXT=26
    WHITESPACE=27
    NEWLINE=28

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.8")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class StmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def line(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(rulesParser.LineContext)
            else:
                return self.getTypedRuleContext(rulesParser.LineContext,i)


        def EOF(self, i:int=None):
            if i is None:
                return self.getTokens(rulesParser.EOF)
            else:
                return self.getToken(rulesParser.EOF, i)

        def getRuleIndex(self):
            return rulesParser.RULE_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStmt" ):
                listener.enterStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStmt" ):
                listener.exitStmt(self)




    def stmt(self):

        localctx = rulesParser.StmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 45
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 42
                self.line()
                self.state = 43
                _la = self._input.LA(1)
                if not(_la==rulesParser.EOF or _la==rulesParser.T__0):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 47
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << rulesParser.INTEGER) | (1 << rulesParser.NUMBER) | (1 << rulesParser.OUTPUT) | (1 << rulesParser.IF) | (1 << rulesParser.ELSE) | (1 << rulesParser.ELSEIF) | (1 << rulesParser.END) | (1 << rulesParser.USE) | (1 << rulesParser.ACTION) | (1 << rulesParser.CLASS_KEY) | (1 << rulesParser.LED) | (1 << rulesParser.VARIABLE))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LineContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def v_init(self):
            return self.getTypedRuleContext(rulesParser.V_initContext,0)


        def conditional(self):
            return self.getTypedRuleContext(rulesParser.ConditionalContext,0)


        def output(self):
            return self.getTypedRuleContext(rulesParser.OutputContext,0)


        def other(self):
            return self.getTypedRuleContext(rulesParser.OtherContext,0)


        def END(self):
            return self.getToken(rulesParser.END, 0)

        def getRuleIndex(self):
            return rulesParser.RULE_line

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLine" ):
                listener.enterLine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLine" ):
                listener.exitLine(self)




    def line(self):

        localctx = rulesParser.LineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_line)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 54
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.state = 49
                self.v_init()
                pass

            elif la_ == 2:
                self.state = 50
                self.conditional()
                pass

            elif la_ == 3:
                self.state = 51
                self.output()
                pass

            elif la_ == 4:
                self.state = 52
                self.other()
                pass

            elif la_ == 5:
                self.state = 53
                self.match(rulesParser.END)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class V_initContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def decl(self):
            return self.getTypedRuleContext(rulesParser.DeclContext,0)


        def assign(self):
            return self.getTypedRuleContext(rulesParser.AssignContext,0)


        def both(self):
            return self.getTypedRuleContext(rulesParser.BothContext,0)


        def getRuleIndex(self):
            return rulesParser.RULE_v_init

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterV_init" ):
                listener.enterV_init(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitV_init" ):
                listener.exitV_init(self)




    def v_init(self):

        localctx = rulesParser.V_initContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_v_init)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 59
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.state = 56
                self.decl()
                pass

            elif la_ == 2:
                self.state = 57
                self.assign()
                pass

            elif la_ == 3:
                self.state = 58
                self.both()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def d_type(self):
            return self.getTypedRuleContext(rulesParser.D_typeContext,0)


        def VARIABLE(self):
            return self.getToken(rulesParser.VARIABLE, 0)

        def getRuleIndex(self):
            return rulesParser.RULE_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDecl" ):
                listener.enterDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDecl" ):
                listener.exitDecl(self)




    def decl(self):

        localctx = rulesParser.DeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_decl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 61
            self.d_type()
            self.state = 62
            self.match(rulesParser.VARIABLE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VARIABLE(self):
            return self.getToken(rulesParser.VARIABLE, 0)

        def EQUAL(self):
            return self.getToken(rulesParser.EQUAL, 0)

        def NUMB(self):
            return self.getToken(rulesParser.NUMB, 0)

        def FLOAT(self):
            return self.getToken(rulesParser.FLOAT, 0)

        def getRuleIndex(self):
            return rulesParser.RULE_assign

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign" ):
                listener.enterAssign(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign" ):
                listener.exitAssign(self)




    def assign(self):

        localctx = rulesParser.AssignContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_assign)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 64
            self.match(rulesParser.VARIABLE)
            self.state = 65
            self.match(rulesParser.EQUAL)
            self.state = 66
            _la = self._input.LA(1)
            if not(_la==rulesParser.NUMB or _la==rulesParser.FLOAT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BothContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def d_type(self):
            return self.getTypedRuleContext(rulesParser.D_typeContext,0)


        def VARIABLE(self):
            return self.getToken(rulesParser.VARIABLE, 0)

        def EQUAL(self):
            return self.getToken(rulesParser.EQUAL, 0)

        def NUMB(self):
            return self.getToken(rulesParser.NUMB, 0)

        def FLOAT(self):
            return self.getToken(rulesParser.FLOAT, 0)

        def getRuleIndex(self):
            return rulesParser.RULE_both

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoth" ):
                listener.enterBoth(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoth" ):
                listener.exitBoth(self)




    def both(self):

        localctx = rulesParser.BothContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_both)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 68
            self.d_type()
            self.state = 69
            self.match(rulesParser.VARIABLE)
            self.state = 70
            self.match(rulesParser.EQUAL)
            self.state = 71
            _la = self._input.LA(1)
            if not(_la==rulesParser.NUMB or _la==rulesParser.FLOAT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class D_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER(self):
            return self.getToken(rulesParser.INTEGER, 0)

        def NUMBER(self):
            return self.getToken(rulesParser.NUMBER, 0)

        def getRuleIndex(self):
            return rulesParser.RULE_d_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterD_type" ):
                listener.enterD_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitD_type" ):
                listener.exitD_type(self)




    def d_type(self):

        localctx = rulesParser.D_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_d_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 73
            _la = self._input.LA(1)
            if not(_la==rulesParser.INTEGER or _la==rulesParser.NUMBER):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def r_if(self):
            return self.getTypedRuleContext(rulesParser.R_ifContext,0)


        def r_elif(self):
            return self.getTypedRuleContext(rulesParser.R_elifContext,0)


        def ELSE(self):
            return self.getToken(rulesParser.ELSE, 0)

        def getRuleIndex(self):
            return rulesParser.RULE_conditional

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditional" ):
                listener.enterConditional(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditional" ):
                listener.exitConditional(self)




    def conditional(self):

        localctx = rulesParser.ConditionalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_conditional)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 78
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [rulesParser.IF]:
                self.state = 75
                self.r_if()
                pass
            elif token in [rulesParser.ELSEIF]:
                self.state = 76
                self.r_elif()
                pass
            elif token in [rulesParser.ELSE]:
                self.state = 77
                self.match(rulesParser.ELSE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class R_ifContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(rulesParser.IF, 0)

        def relation(self):
            return self.getTypedRuleContext(rulesParser.RelationContext,0)


        def VARIABLE(self, i:int=None):
            if i is None:
                return self.getTokens(rulesParser.VARIABLE)
            else:
                return self.getToken(rulesParser.VARIABLE, i)

        def NUMB(self, i:int=None):
            if i is None:
                return self.getTokens(rulesParser.NUMB)
            else:
                return self.getToken(rulesParser.NUMB, i)

        def FLOAT(self, i:int=None):
            if i is None:
                return self.getTokens(rulesParser.FLOAT)
            else:
                return self.getToken(rulesParser.FLOAT, i)

        def getRuleIndex(self):
            return rulesParser.RULE_r_if

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterR_if" ):
                listener.enterR_if(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitR_if" ):
                listener.exitR_if(self)




    def r_if(self):

        localctx = rulesParser.R_ifContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_r_if)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 80
            self.match(rulesParser.IF)
            self.state = 81
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << rulesParser.NUMB) | (1 << rulesParser.FLOAT) | (1 << rulesParser.VARIABLE))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 82
            self.relation()
            self.state = 83
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << rulesParser.NUMB) | (1 << rulesParser.FLOAT) | (1 << rulesParser.VARIABLE))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class R_elifContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ELSEIF(self):
            return self.getToken(rulesParser.ELSEIF, 0)

        def relation(self):
            return self.getTypedRuleContext(rulesParser.RelationContext,0)


        def VARIABLE(self, i:int=None):
            if i is None:
                return self.getTokens(rulesParser.VARIABLE)
            else:
                return self.getToken(rulesParser.VARIABLE, i)

        def NUMB(self, i:int=None):
            if i is None:
                return self.getTokens(rulesParser.NUMB)
            else:
                return self.getToken(rulesParser.NUMB, i)

        def FLOAT(self, i:int=None):
            if i is None:
                return self.getTokens(rulesParser.FLOAT)
            else:
                return self.getToken(rulesParser.FLOAT, i)

        def getRuleIndex(self):
            return rulesParser.RULE_r_elif

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterR_elif" ):
                listener.enterR_elif(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitR_elif" ):
                listener.exitR_elif(self)




    def r_elif(self):

        localctx = rulesParser.R_elifContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_r_elif)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 85
            self.match(rulesParser.ELSEIF)
            self.state = 86
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << rulesParser.NUMB) | (1 << rulesParser.FLOAT) | (1 << rulesParser.VARIABLE))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 87
            self.relation()
            self.state = 88
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << rulesParser.NUMB) | (1 << rulesParser.FLOAT) | (1 << rulesParser.VARIABLE))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RelationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GREATER(self):
            return self.getToken(rulesParser.GREATER, 0)

        def LESS(self):
            return self.getToken(rulesParser.LESS, 0)

        def EQUAL(self):
            return self.getToken(rulesParser.EQUAL, 0)

        def getRuleIndex(self):
            return rulesParser.RULE_relation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelation" ):
                listener.enterRelation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelation" ):
                listener.exitRelation(self)




    def relation(self):

        localctx = rulesParser.RelationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_relation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 90
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << rulesParser.EQUAL) | (1 << rulesParser.GREATER) | (1 << rulesParser.LESS))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OutputContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OUTPUT(self):
            return self.getToken(rulesParser.OUTPUT, 0)

        def VARIABLE(self, i:int=None):
            if i is None:
                return self.getTokens(rulesParser.VARIABLE)
            else:
                return self.getToken(rulesParser.VARIABLE, i)

        def getRuleIndex(self):
            return rulesParser.RULE_output

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOutput" ):
                listener.enterOutput(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOutput" ):
                listener.exitOutput(self)




    def output(self):

        localctx = rulesParser.OutputContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_output)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 92
            self.match(rulesParser.OUTPUT)
            self.state = 94
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 93
                self.match(rulesParser.VARIABLE)
                self.state = 96
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==rulesParser.VARIABLE):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OtherContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def use(self):
            return self.getTypedRuleContext(rulesParser.UseContext,0)


        def class_(self):
            return self.getTypedRuleContext(rulesParser.Class_Context,0)


        def action(self):
            return self.getTypedRuleContext(rulesParser.ActionContext,0)


        def inst(self):
            return self.getTypedRuleContext(rulesParser.InstContext,0)


        def funcall(self):
            return self.getTypedRuleContext(rulesParser.FuncallContext,0)


        def getRuleIndex(self):
            return rulesParser.RULE_other

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOther" ):
                listener.enterOther(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOther" ):
                listener.exitOther(self)




    def other(self):

        localctx = rulesParser.OtherContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_other)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 103
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [rulesParser.USE]:
                self.state = 98
                self.use()
                pass
            elif token in [rulesParser.CLASS_KEY]:
                self.state = 99
                self.class_()
                pass
            elif token in [rulesParser.ACTION]:
                self.state = 100
                self.action()
                pass
            elif token in [rulesParser.LED]:
                self.state = 101
                self.inst()
                pass
            elif token in [rulesParser.VARIABLE]:
                self.state = 102
                self.funcall()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def USE(self):
            return self.getToken(rulesParser.USE, 0)

        def lib(self):
            return self.getTypedRuleContext(rulesParser.LibContext,0)


        def getRuleIndex(self):
            return rulesParser.RULE_use

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUse" ):
                listener.enterUse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUse" ):
                listener.exitUse(self)




    def use(self):

        localctx = rulesParser.UseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_use)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 105
            self.match(rulesParser.USE)
            self.state = 106
            self.lib()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InstContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def lib(self):
            return self.getTypedRuleContext(rulesParser.LibContext,0)


        def VARIABLE(self):
            return self.getToken(rulesParser.VARIABLE, 0)

        def getRuleIndex(self):
            return rulesParser.RULE_inst

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInst" ):
                listener.enterInst(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInst" ):
                listener.exitInst(self)




    def inst(self):

        localctx = rulesParser.InstContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_inst)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 108
            self.lib()
            self.state = 109
            self.match(rulesParser.VARIABLE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LibContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LED(self):
            return self.getToken(rulesParser.LED, 0)

        def getRuleIndex(self):
            return rulesParser.RULE_lib

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLib" ):
                listener.enterLib(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLib" ):
                listener.exitLib(self)




    def lib(self):

        localctx = rulesParser.LibContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_lib)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 111
            self.match(rulesParser.LED)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Class_Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CLASS_KEY(self):
            return self.getToken(rulesParser.CLASS_KEY, 0)

        def VARIABLE(self):
            return self.getToken(rulesParser.VARIABLE, 0)

        def getRuleIndex(self):
            return rulesParser.RULE_class_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClass_" ):
                listener.enterClass_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClass_" ):
                listener.exitClass_(self)




    def class_(self):

        localctx = rulesParser.Class_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_class_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 113
            self.match(rulesParser.CLASS_KEY)
            self.state = 114
            self.match(rulesParser.VARIABLE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ACTION(self):
            return self.getToken(rulesParser.ACTION, 0)

        def ACTION_MAIN(self):
            return self.getToken(rulesParser.ACTION_MAIN, 0)

        def getRuleIndex(self):
            return rulesParser.RULE_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction" ):
                listener.enterAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction" ):
                listener.exitAction(self)




    def action(self):

        localctx = rulesParser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_action)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 116
            self.match(rulesParser.ACTION)
            self.state = 117
            self.match(rulesParser.ACTION_MAIN)
            self.state = 118
            self.match(rulesParser.T__1)
            self.state = 119
            self.match(rulesParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncallContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VARIABLE(self):
            return self.getToken(rulesParser.VARIABLE, 0)

        def funs(self):
            return self.getTypedRuleContext(rulesParser.FunsContext,0)


        def getRuleIndex(self):
            return rulesParser.RULE_funcall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncall" ):
                listener.enterFuncall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncall" ):
                listener.exitFuncall(self)




    def funcall(self):

        localctx = rulesParser.FuncallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_funcall)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 121
            self.match(rulesParser.VARIABLE)
            self.state = 122
            self.match(rulesParser.T__3)
            self.state = 123
            self.funs()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def led_related(self):
            return self.getTypedRuleContext(rulesParser.Led_relatedContext,0)


        def getRuleIndex(self):
            return rulesParser.RULE_funs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuns" ):
                listener.enterFuns(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuns" ):
                listener.exitFuns(self)




    def funs(self):

        localctx = rulesParser.FunsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_funs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 125
            self.led_related()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Led_relatedContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LED_ON(self):
            return self.getToken(rulesParser.LED_ON, 0)

        def LED_OFF(self):
            return self.getToken(rulesParser.LED_OFF, 0)

        def LED_PIN(self):
            return self.getToken(rulesParser.LED_PIN, 0)

        def getRuleIndex(self):
            return rulesParser.RULE_led_related

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLed_related" ):
                listener.enterLed_related(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLed_related" ):
                listener.exitLed_related(self)




    def led_related(self):

        localctx = rulesParser.Led_relatedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_led_related)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 127
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << rulesParser.LED_ON) | (1 << rulesParser.LED_OFF) | (1 << rulesParser.LED_PIN))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx
